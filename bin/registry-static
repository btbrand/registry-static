#!/usr/bin/env node
/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License.
See LICENSE file.
*/
var exec = require('child_process').spawn;
var argv = process.argv.slice(2);
var path = require('path');
var mkdirp = require('mkdirp');
var args = require('../lib/args');
var options = args();
var fs = require('fs');
var strip = require('strip-ansi');

if (options.help || options.version) {
    require('../lib/index');
    return;
}

var logger = require('../lib/logger');
logger();

var log = require('davlog');

var pidFile = path.join(options.tmp, 'registry-static.pid');

if (options.sync) {
    return require('../lib/sync')(options);
}

if (options.restart) {
    var pid = fs.readFileSync(pidFile, 'utf8');
    log.info('\n\n--------------------------------');
    log.info('Restarting process', pid);
    log.info('--------------------------------\n\n');
    process.kill(pid, 'SIGHUP');
    return;
}

var child;

process.on('SIGPIPE', function() {
    //pass SIGPIPE to the child for log rotation
    process.kill(child.pid, 'SIGPIPE');
});

process.on('SIGINT', function() {
    log.info('Cleaning up pidfile');
    fs.unlinkSync(pidFile);
    process.exit();
});

if (fs.existsSync(pidFile)) {
    console.error('\n\n--------------------------------');
    console.error('Found a pid file, is another process running?');
    console.error(pidFile);
    console.error('--------------------------------\n\n');
    process.exit(1);
}

process.on('SIGHUP', function() {
    log.info('\n\n--------------------------------');
    log.info('SIGHUP received, restarting child process (' + child.pid + ')');
    log.info('--------------------------------\n\n');
    process.kill(child.pid, 'SIGKILL');
});

fs.writeFileSync(pidFile, process.pid, 'utf8');

argv.unshift(path.join(__dirname, '../lib/background.js'));
log.info('\n\n--------------------------------');
log.info('starting background task..');
log.info('--------------------------------\n\n');
var proc = 0;
var run = function(c) {
    if (c) {
        //Only count the respawn if there is an exit code
        proc++;
    }
    if (proc >= options.spawn) {
        log.info('\n\n--------------------------------');
        log.info('spawn cap', options.spawn, 'hit, bailing..');
        log.info('--------------------------------\n\n');
        process.exit(1);
    }
    process.env.PROC_SPAWN = proc;
    process.env.PARENT_PID = process.pid;
    child = exec(process.execPath, argv, {
        cwd: process.cwd(),
        env: process.env,
        stdio: 'inherit'
    });
    var a = [];
    var sinceAdded;
    argv.forEach(function(item) {
        switch (item) {
            case '--clean':
                break;
            case '--since':
                sinceAdded = true;
                break;
            default:
                if (sinceAdded) {
                    sinceAdded = null;
                    break;
                }
                a.push(item);
                break;
        }
    });
    argv = a;

    child.on('close', function(code) {
        if (code >= 250) {
            //Internal error..
            process.exit(1);
        }
        log.info('\n\n--------------------------------');
        log.info('subprocess exited with code', code, 'restarting process..');
        log.info('--------------------------------\n\n');
        run(code);
    });
};

//Start the script in a child process, restarting on error..
run();
